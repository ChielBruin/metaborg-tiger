module control-flow

imports ds-signatures/Control-Flow-sig
imports dynamics/base
imports dynamics/store
imports dynamics/natives
imports dynamics/numbers

signature
  constructors
    BreakV : V
  arrows
    E |- evalSeq(List(Exp)) :: H --> V :: H
  
  native operators
    debug  : V -> String
    debugS : String -> String

rules

  Seq(es) --> evalSeq(es).
  
  evalSeq([]) --> UnitV().  
  
  evalSeq([v]) --> v.  
  
  evalSeq([v | es@[_|_]]) --> v
  where
    case v of {
      BreakV() =>
        BreakV() => v
      otherwise =>
        evalSeq(es) --> v
    }.
  
  
  IfThen(e1, e2) --> If(e1, e2, Seq([])).
  
  If(IntV(i), e1, e2) --> v
  where
    case i of {
      0 =>
        e2 --> v
      otherwise =>
        e1 --> v
    }.
  
//  e@While(e1, e2) --> IfThen(e1, Seq([e2, e])).
  
  e@While(e1, e2) --> v
  where
    e1 --> IntV(i);
    case i of {
      0 =>
        UnitV() => v
      otherwise =>
        e2 --> v2;
        case v2 of {
          BreakV() =>
            UnitV() => v
          UnitV() =>
            e --> v
        }
    }.
  
  For(Var(x), e1, e2, e3) -->
    Let([VarDecNoType(x, e1),
         VarDecNoType(end, e2)], 
        [While(Leq(Var(x), Var(end)), Seq([
           e3,
           Assign(Var(x), Plus(Var(x), Int("1")))
         ]))])
  where printI(fresh) : Id => end.  // capture?
  
  Break() --> BreakV().
  