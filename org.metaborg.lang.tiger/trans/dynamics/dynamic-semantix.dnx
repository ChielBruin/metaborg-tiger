module dynamic-semantics

imports
  exp
  records
  flowexp
  binexp
  letexp
  callexp
  arrays
  strings
  dnx-lib
  dnx-stdlib
  
signature
  link-labels
    P
    I
  continuations
    ret
    ex
    next

  namespaces
    Var
    Field
    Loop
  
  init-size = 15
    
rules
  eval(m@Mod(exp)) =
    compile-builtins(m);
    eval-instr(exp, m);
    exitOK()
   
  eval-instr(exp:UNIT(), _) = 
  	v1 <- eval-exp(exp)
   
  eval-instr(exp:RECORD(_), _) = 
  	rec <- eval-exp(exp);
  	printc(int(36));
  	printc(int(82));
  	printc(int(101));
  	printc(int(99));
  	printc(int(111));
  	printc(int(114));
  	printc(int(100))
   
  eval-instr(exp:ARRAY(_, _), _) = 
  	rec <- eval-exp(exp);
  	printc(int(36));
  	printc(int(65));
  	printc(int(114));
  	printc(int(114));
  	printc(int(97));
  	printc(int(121))
    
  eval-instr(exp:INT(), m) = 
    v1 <- eval-exp(Call("printi"@m, [exp]))
    
  eval-instr(exp:STRING(), m) = 
    v1 <- eval-exp(Call("print"@m, [exp]))
    
rules
  compile-builtins(m) = 
    compile-chr(m);
    compile-print(m);
    compile-print-int(m);
    compile-timing(m)
    
  compile-timing(m) =
    tick_b = <
    	tick();
    	res <- null();
    	func-return(res, $ret)
    >;
    set(cur(), resolve("timeGo"@m, "Var"), tick_b);
    
    tock_b = <
    	tock();
    	res <- null();
    	func-return(res, $ret)
    >;
    set(cur(), resolve("timeStop"@m, "Var"), tock_b)
    
  compile-chr(m) =
    chr_b = <
    	val <- get(cur(), [0]);
    	string <- new(int(1));
    	set(string, [0], val);
    	func-return(string, $ret)
    >;
    set(cur(), resolve("chr"@m, "Var"), chr_b)
    
  compile-print(m) = 
    print_b = <
      dnx_print <- dnx-print-string($ret);
      cf <- newCF(cur());
      setC(cf, $ret, curC(~ret));
      callCF(cf, dnx_print)
    >;
    ret = <
      func-return(null(), $ret)
    >;
    set(cur(), resolve("print"@m, "Var"), print_b)
    
  compile-print-int(m) =       
    to_string = <
      itos <- dnx-int-to-string($ret);
      df <- new(int(1));
      set(df, [0], get(cur(), [0]));
      cf <- newCF(df);
      setC(cf, $ret, curC(~print_string));
      callCF(cf, itos)
    >;
    
    print_string = <
      print_s <- dnx-print-string($ret);
      string <- pop();
      df <- new(int(1));
      set(df, [0], string);
      cf <- newCF(df);
      setC(cf, $ret, curC(~ret));
      callCF(cf, print_s)
    >;
    
    ret = <
      func-return(null(), $ret)
    >;
    set(cur(), resolve("printi"@m, "Var"), to_string)
    