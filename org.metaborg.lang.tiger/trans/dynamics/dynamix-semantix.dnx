module dynamic-semantics

imports
  exp
  records
  flowexp
  binexp
  letexp
  callexp
  
rules
  map[ast -> instr]:: ast -> instr 
  map[x]([e]) =
    x(e)
    
  map[x]([h|t]) =
    x(h);
    map[x](t)

  exitOK:: -> instr
  exitOK() = 
    rcf <- getCF(curCF(), $ret);
    push(int(0), rcf);
    returnCF(rcf)
    
  resolveVar:: ast -> ast
  resolveVar(name) = resolve(name, "Var")
    
rules
  eval:: ast -> instr
  eval(Mod(exp)) =
   val <- eval-exp(exp);
   print(val);
   exitOK()
   

   
  eval-exp:: ast -> val
  eval-exp(Int(v)) = return(int(v))
  
  eval-exp(Plus(left, right)) = 
    v1 <- eval-exp(left);
    v2 <- eval-exp(right);
    return(iadd(v1, v2))
    
  eval-exp(Let(binds, body)) =
    old_s <- cur();
    eval-let-binds(binds);
    res <- eval-let-body(body);
    mkcur(old_s);
    return(res)
    
  eval-exp(Var(name)) = return(get(cur(), resolveVar(name)))
    
rules // Let internal rules
  eval-let-body:: ast -> val
  eval-let-body([exp]) =
    v1 <- eval-exp(exp);
    return(v1)
      
  eval-let-body([exp | tail]) =
    v1 <- eval-exp(exp);
    return(eval-let-body(tail))
    
  eval-let-binds:: ast -> instr
  
  
  // How do we do the empty case?
  // This would require a nop or something
  eval-let-binds([]) = 
    continue()
    
  eval-let-binds([FunDecs(funcs) | tail]) =
    scope <- new(int(0));
    link(scope, [], &P);
    mkcur(scope);
    new_s <- eval-let-binds(funcs);
    eval-let-binds(tail)
    
  func-return:: val -> return
  func-return(val) =
    rcf <- getCF(curCF(), $ret);
    push(val, rcf);
    returnCF(rcf)
    
  eval-let-binds([FunDec(name, args, _, body) | tail]) =
    scope <- new(int(0));
    link(scope, [], &P);
    mkcur(scope);
    
    q <- zip-with-index(args);
    map[associate-args](q);
    fun_body <- <
      v13 <- eval-exp(~body);
      func-return(v13)
    >;
    associate-label(fun_body, name, "Var");
    eval-let-binds(tail)
    
  eval-exp(Call("chr", [arg])) =
    v1 <- eval-exp(arg);
    // TODO: This should return a string, not a char
    return(iadd(int(48), v1))
    
  eval-exp(Call("print", [arg])) =
    v1 <- eval-exp(arg);
    // TODO: This should print strings, not chars
    printc(v1);
    printc(int(10)); // Newline
    // TODO: Should be void/null
    return(new(int(0)))
    
  eval-exp(Call(name, args)) =
    callFrame <- new(int(length(args)));
    store-args(zip-with-index(args), callFrame);
    link(callFrame, get(cur(), resolve-scope(name, "Var")), &P);
    callCF <- newCF(callFrame, resolve-label(name, "Var"), int(1));
    setCF(callCF, $ret, curCF());
    callCF(callCF);
    return(pop(curCF()))
  
  associate-args:: ast -> instr
  associate-args( (idx, FArg(name, _)) ) =
    associate-index(idx, name, "Var") 
  
  store-args:: ast -> val -> instr
  store-args([], _) = continue()
  
  store-args( [(idx, exp) | t ], frame ) =
    val <- eval-exp(exp);
    set(frame, [idx], val);
    store-args(t, frame)
    
  eval-let-binds([VarDec(name, _, val) | tail]) = 
    v1 <- eval-exp(val);
    scope <- new(int(1));
    link(scope, [], &P);
    mkcur(scope);
    set(scope, resolveVar(name), v1);
    eval-let-binds(tail)
    
  eval-let-binds([VarDecNoType(name, val) | tail]) = 
    v1 <- eval-exp(val);
    scope <- new(int(1));
    link(scope, [], &P);
    mkcur(scope);
    set(scope, resolveVar(name), v1);
    eval-let-binds(tail)
    
  eval-let-binds([TypeDecs(_) | tail]) = 
    scope <- new(int(0));
    link(scope, [], &P);
    mkcur(scope);
    eval-let-binds(tail)
    
  eval-exp(If(cond, then, else)) = 
    c <- eval-exp(cond);
    jumpz(c, ELSE, THEN);
   THEN;
    v1 <- eval-exp(then);
    jump(CONT);
   ELSE;
    v1 <- eval-exp(else);
    jump(CONT);
   CONT;
    return(v1)
    
  eval-exp(Gt(e1, e2)) =
    v1 <- eval-exp(e1);
    v2 <- eval-exp(e2);
    return(igt(v1, v2))
    
  eval-exp(Lt(e1, e2)) =
    v1 <- eval-exp(e1);
    v2 <- eval-exp(e2);
    return(ilt(v1, v2))
    
  eval-exp(Minus(e1, e2)) =
    v1 <- eval-exp(e1);
    v2 <- eval-exp(e2);
    return(isub(v1, v2))
    
  eval-exp(Times(e1, e2)) =
    v1 <- eval-exp(e1);
    v2 <- eval-exp(e2);
    return(imul(v1, v2))
    
  eval-exp(Seq(list)) =
    return(eval-seq(list))
    
  eval-seq:: ast -> val
  eval-seq([h]) = 
    v1 <- eval-exp(h);
    return(v1)
  eval-seq([h | t]) = 
    v1 <- eval-exp(h);
    return(eval-seq(t))
    
  eval-exp(For(Var(idx_var), init, cond, body)) =
    vi <- eval-exp(init);
    max <- eval-exp(cond);
    scope <- new(int(1));
    link(scope, [], &P);
    mkcur(scope);
    idx_path <- resolveVar(idx_var);
    set(cur(), idx_path, vi);
    jump(FOR);
   FOR;
    cur <- get(cur(), idx_path);
    jumpz(igt(cur, max), FOR_BODY, FOR_END);
   FOR_BODY;
    v1 <- eval-exp(body);
    
    // increment loop index
    set(cur(), idx_path, iadd(get(cur(), idx_path), int(1)));
    jump(FOR);
   FOR_END;
    mkcur(get(cur(), [&P]));
    // TODO: Should be a void return
    return(new(int(0)))
    
  eval-exp(Assign(Var(var), exp)) =
    v1 <- eval-exp(exp);
    set(cur(), resolveVar(var), v1);
    // TODO: Should be a void return
    return(new(int(0)))
    
  eval-exp(Record(_, vals)) =
    rec <- new(int(length(vals)));
    store-field(zip-with-index(vals), rec);
    return(rec)
    
  
  store-field:: ast -> val -> instr
  store-field([], _) = continue()
  
  store-field( [(idx, InitField(name, exp)) | t ], frame ) =
    val <- eval-exp(exp);
    set(frame, [idx], val);
    associate-index(idx, name, "Field");
    store-field(t, frame)
    
  eval-exp(FieldVar(Var(name), slot)) =
    rec <- get(cur(), resolveVar(name));
    s <- new(int(0));
    link(s, rec, &I);
    val <- get(s, resolve(slot, "Field"));
    return(val)
  
  eval-exp(NilExp()) = return(new(int(0)))
    
    
    