module binexp

rules 
  eval-exp(Plus(left, right)) = 
    v1 <- eval-exp(left);
    v2 <- eval-exp(right);
    return(iadd(v1, v2))
    
  eval-exp(Gt(e1, e2)) =
    v1 <- eval-exp(e1);
    v2 <- eval-exp(e2);
    return(igt(v1, v2))
  
  eval-exp(Lt(e1, e2)) =
    v1 <- eval-exp(e1);
    v2 <- eval-exp(e2);
    return(ilt(v1, v2))
    
  eval-exp(Geq(e1, e2)) =
    v1 <- eval-exp(e1);
    v2 <- eval-exp(e2);
    // Todo: fix this, it does not follow the Tiger spec
    return(ior(igt(v1, v2), ieq(v1, v2)))
    
  eval-exp(Leq(e1, e2)) =
    v1 <- eval-exp(e1);
    v2 <- eval-exp(e2);
    return(ior(ilt(v1, v2), ieq(v1, v2)))
    
  eval-exp(Minus(e1, e2)) =
    v1 <- eval-exp(e1);
    v2 <- eval-exp(e2);
    return(isub(v1, v2))
    
  eval-exp(Eq(e1, e2:INT())) =
    v1 <- eval-exp(e1);
    v2 <- eval-exp(e2);
    return(ieq(v1, v2))
    
  eval-exp(Neq(e1, e2:INT())) =
    v1 <- eval-exp(e1);
    v2 <- eval-exp(e2);
    return(isub(int(1), ieq(v1, v2)))
    
  
    
  eval-exp(Eq(e1, e2)) =
    v1 <- eval-exp(e1);
    v2 <- eval-exp(e2);
    return(req(v1, v2))
    
  eval-exp(Neq(e1, e2)) =
    v1 <- eval-exp(e1);
    v2 <- eval-exp(e2);
    return(isub(int(1), req(v1, v2)))
    
  eval-exp(Times(e1, e2)) =
    v1 <- eval-exp(e1);
    v2 <- eval-exp(e2);
    return(imul(v1, v2)) 
    
  eval-exp(Divide(e1, e2)); k(idiv(v1, v2)) =
    !v1;
    throw_b = <
      callC(getC(curCF(), $ex), ~v1)
    >;
    
    v1 <- eval-exp(e1);
    v2 <- eval-exp(e2);
    jumpz(ieq(v2, int(0)), k, throw_b)  
    
  eval-exp(And(e1, e2)) =
    v1 <- eval-exp(e1);
    v2 <- eval-exp(e2);
    return(iand(v1, v2))    
