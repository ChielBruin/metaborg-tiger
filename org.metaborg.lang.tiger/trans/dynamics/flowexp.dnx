module flowexp

imports dnx-lib

rules
  eval-exp(IfThen(cond, then)); k(null()) = 
   then_b = <
      v1 <- eval-exp(~then);
      jump(~k)
    >;
    
    c <- eval-exp(cond);
    jumpz(c, k, then_b)
  
  eval-exp(If(cond, then, else)); k(v1) =
    !v1;
    
    c <- eval-exp(cond);
    jumpz(c, else_b, then_b);
    
    then_b = <
      ~v1 <- eval-exp(~then);
      jump(~k)
    >;
    else_b = <
      ~v1 <- eval-exp(~else);
      jump(~k)
    >
    
  eval-exp(For(Var(idx_var), init, cond, body)); k(null()) =
    idx_path = resolve(idx_var, "Var");
    !f_max;
    f_init = <
      ~f_max <- pop();
      jump(~f_check)
    >;
    f_body = <
      v1 <- eval-exp(~body);
      // increment loop index
      set(cur(), ~idx_path, iadd(get(cur(), ~idx_path), int(1)));
      jump(~f_check)
    >;
    f_end = <
      callC(getC(curCF(), $break))
    >;
    f_check = <
      cur <- get(cur(), ~idx_path);
      jumpz(igt(cur, ~f_max), ~f_body, ~f_end)
    >;

    vi <- eval-exp(init);
    max <- eval-exp(cond);
    scope <- new(int(1));
    link(scope, [], &P);
    set(scope, idx_path, vi);
    
    loop_cf <- newCF(scope);
	setC(loop_cf, $break, curC(k));
    
    callC(newC(loop_cf, f_init), max)
    
  eval-exp(While(cond, body)); k(null()) =    
    w_cond = <
      c <- eval-exp(~cond);
      jumpz(c, ~w_end, ~w_body)
    >;
    w_body = <
      scope <- new(int(0));
      link(scope, [], &P);
    
      mkcur(scope);    
      v1 <- eval-exp(~body);
    
      mkcur(get(cur(), [&P]));
      jump(~w_cond)
    >;
    w_end = <
      callC(getC(curCF(), $break))
    >;
    
    w_cf <- newCF(cur());
	setC(w_cf, $break, curC(k));
    callCF(w_cf, w_cond)
   
  eval-exp(Break()) =
    callC(getC(curCF(), $break))

