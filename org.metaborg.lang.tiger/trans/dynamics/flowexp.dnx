module flowexp

imports dnx-lib

rules // Try-catch
  eval-exp(TryCatch(try_exp, Var(var), catch_exp)); k(null()) =
    try_b = <
      v <- eval-exp(~try_exp);
      callC(getC(curCF(), $next))
    >;
    catch_b = <
      val <- pop();
      set(cur(), resolve(~var, "Var"), val);
      v <- eval-exp(~catch_exp);
      callC(getC(curCF(), $next))
    >;
    
    try_df   <- new(int(0));
    catch_df <- new(int(1));
    
    link(try_df  , cur(), &P);
    link(catch_df, cur(), &P);
    
    try_cf   <- newCF(try_df);
    catch_cf <- newCF(catch_df);

    next <- curC(k);
    
    setC(try_cf  , $ex  , newC(catch_cf, catch_b));
    setC(try_cf  , $next, next);

    setC(catch_cf, $next, next);
    
    callCF(try_cf, try_b)
    
  eval-exp(Throw(exp)); k(null()) =
    v <- eval-exp(exp);
    callC(getC(curCF(), $ex), v)

rules // For in
  eval-exp(stmt@ForIn(Var(var), gen_exp, body)); k(null()) =
    break_path = resolve("__break__"@stmt, "Loop");
    var_path = resolve(var, "Var");
    exec_body_init = <
      gen <- get(cur(), resolve(~var, "Var"));
      gen_cf <- unpackC(gen);
      setC(gen_cf, $yield, curC(~exec_body));
      callC(gen)
    >;
    exec_body = <
      gen <- pop();
      val <- pop();
      set(cur(), resolve(~var, "Var"), val);
      v <- eval-exp(~body);
      callC(gen)
    >;
    gen <- eval-exp(gen_exp);
    for_s <- new(int(2));
    link(for_s, cur(), &P);
    
    exit_c <- curC(k);
    set(for_s, break_path, exit_c);
    set(for_s, var_path, gen);
    
    for_cf <- newCF(for_s);
    setC(unpackC(gen), $ret, exit_c);
    callCF(for_cf, exec_body_init)
    
  eval-exp(Yield(exp)); k(null()) = 
    val <- eval-exp(exp);
    callC(getC(curCF(), $yield), val, curC(k))
    
rules
  eval-exp(IfThen(cond, then)); k(null()) = 
   then_b = <
      v1 <- eval-exp(~then);
      jump(~k)
    >;
    
    c <- eval-exp(cond);
    jumpz(c, k, then_b)
  
  eval-exp(If(cond, then, else)); k(v1) =
    !v1;
    
    c <- eval-exp(cond);
    jumpz(c, else_b, then_b);
    
    then_b = <
      ~v1 <- eval-exp(~then);
      jump(~k)
    >;
    else_b = <
      ~v1 <- eval-exp(~else);
      jump(~k)
    >
    
  eval-exp(stmt@For(Var(idx_var), init, cond, body)); k(null()) =
    idx_path = resolve(idx_var, "Var");
    break_path = resolve("__break__"@stmt, "Loop");
    !max;
    f_body = <
      v1 <- eval-exp(~body);
      // increment loop index
      set(cur(), ~idx_path, iadd(get(cur(), ~idx_path), int(1)));
      jump(~f_check)
    >;
    f_end = <
      mkcur(get(cur(), [&P]));
      jump(~k)
    >;
    f_check = <
      cur <- get(cur(), ~idx_path);
      jumpz(igt(cur, ~max), ~f_body, ~f_end)
    >;

    vi <- eval-exp(init);
    max <- eval-exp(cond);
    scope <- new(int(2));
    link(scope, [], &P);
    mkcur(scope);
    set(cur(), break_path, curC(f_end));
    set(cur(), idx_path, vi);
    jump(f_check)
    
  eval-exp(stmt@While(cond, body)); k(null()) =
    break_path = resolve("__break__"@stmt, "Loop");
    
    w_cond = <
      c <- eval-exp(~cond);
      jumpz(c, ~k, ~w_body)
    >;
    w_body = <
      scope <- new(int(1));
      link(scope, [], &P);
    
      mkcur(scope);
      set(cur(), ~break_path , curC(~w_break));
    
      v1 <- eval-exp(~body);
    
      mkcur(get(cur(), [&P]));
      jump(~w_cond)
    >;
    w_break = <
      mkcur(get(cur(), [&P]));
      jump(~k)
    >;
    
   jump(w_cond)
   
    
  eval-exp(b@Break()); k(null()) =
    break = "__break__"@b;
    callC(get(cur(), resolve(break, "Loop")))

