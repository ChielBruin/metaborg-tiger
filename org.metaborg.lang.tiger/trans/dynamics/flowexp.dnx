module flowexp

imports dnx-lib

rules // Try-catch
  eval-exp(TryCatch(try_exp, Var(var), catch_exp)); k(null()) =
    try_b = <
      v <- eval-exp(~try_exp);
      callC(getC(curCF(), $next))
    >;
    catch_b = <
      val <- pop();
      set(cur(), resolve(~var, "Var"), val);
      v <- eval-exp(~catch_exp);
      callC(getC(curCF(), $next))
    >;
    
    try_df   <- new(int(0));
    catch_df <- new(int(1));
    
    link(try_df  , cur(), &P);
    link(catch_df, cur(), &P);
    
    try_cf   <- newCF(try_df, int(3));
    catch_cf <- newCF(catch_df, int(3));

    next <- curC(k);
    
    setC(try_cf  , $ret , getC(curCF(), $ret));
    setC(try_cf  , $ex  , newC(catch_cf, catch_b));
    setC(try_cf  , $next, next);

    setC(catch_cf, $ret , getC(curCF(), $ret));
    setC(catch_cf, $ex  , getC(curCF(), $ex));
    setC(catch_cf, $next, next);
    
    callCF(try_cf, try_b)
    
  eval-exp(Throw(exp)); k(null()) =
    v <- eval-exp(exp);
    callC(getC(curCF(), $ex), v)
    
rules
  eval-exp(IfThen(cond, then)); k(null()) = 
   then_b = <
      v1 <- eval-exp(~then);
      jump(~k)
    >;
    
    c <- eval-exp(cond);
    jumpz(c, k, then_b)
  
  eval-exp(If(cond, then, else)); k(v1) =
    !v1;
    
    c <- eval-exp(cond);
    jumpz(c, else_b, then_b);
    
    then_b = <
      ~v1 <- eval-exp(~then);
      jump(~k)
    >;
    else_b = <
      ~v1 <- eval-exp(~else);
      jump(~k)
    >
    
  eval-exp(stmt@For(Var(idx_var), init, cond, body)); k(null()) =
    idx_path = resolve(idx_var, "Var");
    break_path = resolve("__break__"@stmt, "Loop");
    !max;
    f_body = <
      v1 <- eval-exp(~body);
      // increment loop index
      set(cur(), ~idx_path, iadd(get(cur(), ~idx_path), int(1)));
      jump(~f_check)
    >;
    f_end = <
      mkcur(get(cur(), [&P]));
      jump(~k)
    >;
    f_check = <
      cur <- get(cur(), ~idx_path);
      jumpz(igt(cur, ~max), ~f_body, ~f_end)
    >;

    vi <- eval-exp(init);
    max <- eval-exp(cond);
    scope <- new(int(2));
    link(scope, [], &P);
    mkcur(scope);
    set(cur(), break_path, f_end);
    set(cur(), idx_path, vi);
    jump(f_check)
    
  eval-exp(stmt@While(cond, body)); k(null()) =
    break_path = resolve("__break__"@stmt, "Loop");
    
    w_cond = <
      c <- eval-exp(~cond);
      jumpz(c, ~k, ~w_body)
    >;
    w_body = <
      scope <- new(int(1));
      link(scope, [], &P);
    
      mkcur(scope);
      set(cur(), ~break_path , ~w_break);
    
      v1 <- eval-exp(~body);
    
      mkcur(get(cur(), [&P]));
      jump(~w_cond)
    >;
    w_break = <
      mkcur(get(cur(), [&P]));
      jump(~k)
    >;
    
   jump(w_cond)
   
    
  eval-exp(b@Break()); k(null()) =
    break = "__break__"@b;
    path = resolve-scope(break, "Loop");
    
    mkcur(get(cur(), path));
    jump(get(cur(), resolve(break, "Loop")))

