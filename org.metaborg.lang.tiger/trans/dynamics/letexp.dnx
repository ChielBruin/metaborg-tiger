module letexp

imports dnx-lib

rules
  eval-exp(Let(binds, body)) =
    old_s <- cur();
    eval-let-binds(binds);
    res <- eval-let-body(body);
    mkcur(old_s);
    return(res)
 
// Let internal rules
rules // Let body
  eval-let-body([exp]) =
    v1 <- eval-exp(exp);
    return(v1)
      
  eval-let-body([exp | tail]) =
    v1 <- eval-exp(exp);
    return(eval-let-body(tail))

rules // Let bindings
  eval-let-binds([]) = 
    nop()
    
  eval-let-binds([FunDecs(funcs) | tail]) =
    scope-new(int(length(funcs)));
    eval-let-binds(funcs);
    eval-let-binds(tail)
    
  eval-let-binds([FunDec(name, args, _, body) | tail]) =
    eval-let-binds([ProcDec(name, args, body) | tail])
    
  eval-let-binds([ProcDec(name, args, body) | tail]) =
    q = zip-with-index(args);
    map[associate-args](q);
    fun_body = <
      v1 <-eval-exp(~body);
      func-return(v1, $ret)
    >;
    variable-assign(name, "Var", fun_body);
    eval-let-binds(tail)
    
  associate-args( (idx, FArg(name, _)) ) =
    associate-index(idx, name, "Var")
    
  eval-let-binds([VarDec(name, _, val) | tail]) = 
    eval-let-binds([VarDecNoType(name, val) | tail])
    
  eval-let-binds([VarDecNoType(name, val) | tail]) = 
    v1 <- eval-exp(val);
    scope-new(int(1));
    variable-assign(name, "Var", v1);
    eval-let-binds(tail)
    
  eval-let-binds([TypeDecs(decs) | tail]) = 
    scope-new(int(0));
    eval-let-binds(tail)