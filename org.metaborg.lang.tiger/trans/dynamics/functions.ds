module dynamics/functions

imports ds-signatures/Functions-sig
imports dynamics/base
imports dynamics/store
imports dynamics/strings
imports dynamics/bindings
imports dynamics/natives
imports dynamics/numbers

signature
  sorts
  
  constructors
    ClosureV : List(FArg) * Exp * Frame -> V
  arrows
    fdecs(List(FunDec)) --> U
    fdec(FunDec) --> U
    evalArgs(List(FArg), List(Exp), Frame) --> U

rules // 

  default(FUN(_, _)) --> UndefV()
  
rules // function definition

  FunDecs(fds) --> fdecs(fds)
  
  fdecs([]) --> U()
  
  fdecs([fd | fds]) --> fdecs(fds)
  where
    fdec(fd) --> U()
  
  FS (F, _) : (Frame * Frame) |- fdec(d@FunDec(x : Occurrence, args, _, e)) --> U()
  where
    bodyScope(d) --> s_fun;
    initFrame(s_fun, { P() |--> { scopeOf(F) : Scope |--> F}}, {}) --> F_fun;
    set(Addr(F, x), ClosureV(args, e, F_fun))  --> _

  Call(f : Occurrence, args) --> v
  where
    get(lookup(pathOf(f))) --> ClosureV(fps, e, F_fun_proto);
    copyOf(F_fun_proto) --> F_fun;
    evalArgs(fps, args, F_fun) --> _;
    F_fun |- e --> v
  
  evalArgs([], [], _) --> U()
  
  evalArgs([FArg(x : Occurrence, _) | args], [vv | es], F_fun) --> evalArgs(args, es, F_fun)
  where
    set(mkAddr(F_fun, x), vv) --> _
  

rules // procedure definition
  
  FS (F, _) : (Frame * Frame) |- fdec(d@ProcDec(x : Occurrence, args, e)) --> U()
  where
    bodyScope(d) --> s_fun;
    initFrame(s_fun, { P() |--> { scopeOf(F) : Scope |--> F}}, {}) --> F_fun;
    set(mkAddr(F, x), ClosureV(args, e, F_fun))  --> _

