module dynamics-frames-directed/control-flow

imports
  dynamics-frames-directed/base
  dynamics-frames-directed/numbers
  dynamics-frames-directed/stdlib/loop

signature
  arrows
    Seq-Exps(List(Exp)) --> V
  
rules

  Seq(es) --> Seq-Exps(es)
  
  Seq-Exps([]) --> UnitV()
  
  Seq-Exps([e]) --> e
  
  Seq-Exps([e | es@[_|_]]) --> Seq-Exps(es)
  where
    e --> _
  
  IfThen(e1, e2) --> If(e1, e2, Seq([]))
  
  If(IntV(i), e1, e2) --> vv
  where
    case i of {
      0 =>
        e2 --> vv
      otherwise =>
        e1 --> vv
    }
    
signature
  constructors
    IsInt1: Exp -> Condition 
    AddrLte: Addr * Int -> Condition
    WhileBody: Exp -> Evaluatable
    IncAddr: Addr -> Evaluatable
    __Exp2Evaluatable__ : Exp -> Evaluatable {implicit}
rules

  Break() --> UnitV()
  where
    do-break() --> _

  F |- w@While(e1, e2) --> UnitV()
  where
//    while-loop-brekable(\ e1 --> IntV(i); i == 0 \, \ initDefFrame(bodyScope(w), [P(F)]) --> F'; F' |- e2 --> v \) --> _;
    while-loop-breakable(IsInt1(e1), WhileBody(w)) --> _
  
  IsInt1(e) --> bv
  where
    e --> IntV(i);
    case i of {
      1 => true => bv
      otherwise => false => bv
    }
  
  F |- WhileBody(w@While(_, e2)) --> v
  where
    initFrame(bodyScope(w), [P(F)]) --> F';
    F' |- e2 --> v
  
  F |- stm@For(Var(x : Occurrence), e1, e2, e3) --> UnitV()
  where
    F |- e1 --> v1@IntV(_);
    F |- e2 --> IntV(i2);
    initFrame(bodyScope(stm), [P(F)]) --> F_for;
    mkAddr(F_for, x) --> x_addr;
    set(x_addr, v1) --> _;
//  while-loop-breakable(\ get(x_addr) --> IntV(i); leqI(i1, i2) \, \ e3 --> _; get(x_addr) --> IntV(i); set(x_addr, addI(i, 1)) --> _ \) --> _
    F_for |- while-loop-breakable(AddrLte(x_addr, i2), EvSeq(e3, IncAddr(x_addr))) --> _
  
  AddrLte(addr, i2) --> bv
  where
    get(addr) --> IntV(i1);
    case leqI(i1, i2) of {
      1 => true => bv
      otherwise => false => bv
    }
  
  IncAddr(addr) --> UnitV()
  where
    get(addr) --> IntV(i);
    set(addr, IntV(addI(i, 1))) --> _

  __Exp2Evaluatable__(e) --> e
