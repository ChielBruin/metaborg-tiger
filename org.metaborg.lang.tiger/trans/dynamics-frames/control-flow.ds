module dynamics-frames/control-flow

imports ds-signatures/Control-Flow-sig
imports dynamics-frames/base
imports dynamics-frames/store
imports dynamics-frames/natives
imports dynamics-frames/numbers

signature
  constructors
    BreakV : V
    Breakable : Exp * Exp -> Exp
  arrows
    evalSeq(List(Exp)) --> V
  
  sorts
    BreakFlag
  
  constructors
    OK: BreakFlag
    BR: BreakFlag
  
  components
    B : BreakFlag = OK()
  
rules

  Seq(es) --> evalSeq(es)
  
  evalSeq([]) --> UnitV()
  
  evalSeq([vv]) --> vv
  
  evalSeq([vv | es@[_|_]]) --> vv
  where
    case vv of {
      BreakV() =>
        BreakV() => vv
      otherwise =>
        evalSeq(es) --> vv
    }
  
  
  IfThen(e1, e2) --> If(e1, e2, Seq([]))
  
  If(IntV(i), e1, e2) --> vv
  where
    case i of {
      0 =>
        e2 --> vv
      otherwise =>
        e1 --> vv
    }
  
  F |- w@While(e1, e2) --> UnitV()
  where
    F |- e1 --> IntV(i);
    case i of {
      1 =>
        initFrame(bodyScope(w), { P() |--> { scopeOf(F) : Scope |--> F }}, {}) --> F';
        F' |- e2 :: B OK() --> _ :: B';
        case B' of {
          OK() =>
            F |- w --> _
          otherwise =>
        }
      otherwise =>
    }
  
  F |- stm@For(Var(x : Occurrence), IntV(i_start), IntV(i_end), e3) --> UnitV()
  where
    initFrame(bodyScope(stm), { P() |--> { scopeOf(F) : Scope |--> F } }, {}) --> F_for;
    F_for |- for-loop(x, i_start, i_end, e3) --> _

signature
  arrows
    for-loop(Occurrence, Int, Int, Exp) --> V

rules
  
  F |- for-loop(x, i, j, e) --> UnitV()
  where
    case leqI(i, j) of {
      1 =>
        set(mkAddr(F, x), IntV(i)) --> _;
        F |- e :: B OK() --> _ :: B';
        case B' of {
          OK() =>
            F |- for-loop(x, addI(i, 1), j, e) --> _
          otherwise =>
        }
      0 =>
    }

//  e@While(e1, e2) --> IfThen(e1, Breakable(e2, e))
//  
//  Breakable(v1, e2) --> vv
//  where
//    case v1 of {
//      BreakV() =>
//        UnitV() => vv
//      otherwise =>
//        e2 --> vv
//    }
//  
//  For(Var(x), e1, e2, e3) -->
//    Let([VarDecNoType(x, e1),
//         VarDecNoType(__Id2Occ__(end), e2)], 
//        [While(Leq(Var(x), Var(__Id2Occ__(end))), Seq([
//           e3,
//           Assign(Var(x), Plus(Var(x), Int("1")))
//         ]))])
//  where printI(fresh) : Id => end  // capture?
//  
  Break() :: B OK() --> ??? :: B BR()
  
