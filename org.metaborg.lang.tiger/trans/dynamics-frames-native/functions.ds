module dynamics-frames-native/functions


imports
  dynamics-frames-native/base
  dynamics-frames-native/bindings
  
signature
  arrows
    Frames1 |- Map2-FunDecs(List(FunDec)) --> U
    Frames1 |- FunDec --> U
    unpackArgs(List(FArg)) --> List(Occurrence)
    F |- Map-Exps(List(Exp)) --> List(Val)
    F |- setArgs(List(Occurrence), List(Val)) --> U
    
  constructors
    FunV: Frame * List(Occurrence) * Exp -> V

rules
  
  default(FUN(_, _)) --> UndefV()

rules // function declarations

  Frames1 (F, F_outer) |- Dec(FunDecs(fdecs)) --> U()
  where
    Frames1 (F, F_outer) |- Map2-FunDecs(fdecs) --> _
  
  Frames1 (F, F') |- Map2-FunDecs([]) --> U()
  
  Frames1 (F, F') |- Map2-FunDecs([x|xs]) --> U()
  where
    Frames1 (F, F') |- x --> _;
    Frames1 (F, F') |- Map2-FunDecs(xs) --> _  
  
  Frames1 (F, F_outer) |- d@ProcDec(f : Occurrence, args, e) --> U()
  where
    framed(d, [L(P(), F)]) => F_fun;
    set(F, f, FunV(F_fun, unpackArgs(args), e)) => _
  
  Frames1 (F, F_outer) |- d@FunDec(f : Occurrence, args, t, e) --> U()
  where
    framed(d, [L(P(), F)]) => F_fun;
    set(F, f, FunV(F_fun, unpackArgs(args), e)) => _
  
  F F |- Call(f : Occurrence, exps) --> v
  where
    // FIXME: fetch function body from SG and evaluate it, instead of getting from closure
    get(lookup(F, f)) => FunV(F_fun_virt, args, e);
    clone(F_fun_virt) => F_call;
    F F |- Map-Exps(exps) --> vals;
    F F_call |- setArgs(args, vals) --> _;
    F F_call |- e --> v

  unpackArgs([]) --> []
  
  unpackArgs([FArg(x : Occurrence, _) | args]) --> [x |occs]
  where
    unpackArgs(args) --> occs
  
  setArgs([], []) --> U()
  
  F |- setArgs([x|xs],[v|vs]) --> setArgs(xs, vs)
  where
    set(lookup(F, x), v) => _

  F F |- Map-Exps([]) --> []
  
  F F |- Map-Exps([e|es]) --> [v|vs]
  where
    F F |- e --> v;
    F F |- Map-Exps(es) --> vs
